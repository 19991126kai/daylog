<%# 戻るボタン %>
<%= link_to categories_path,
  class: "inline-flex items-center justify-center w-10 h-10 rounded-full border border-gray-300 text-gray-700 hover:bg-gray-100 hover:border-gray-400 transition",
  aria: { label: "戻る" } do %>
  <svg class="w-5 h-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
    <path d="M7.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4A1 1 0 018.707 6.293L6.414 8.586H17a1 1 0 110 2H6.414l2.293 2.293a1 1 0 010 1.414z"/>
  </svg>
<% end %>

<section class="max-w-3xl mx-auto px-4">
  <h2 class="text-2xl font-bold text-blue-900 my-6 border-b border-blue-900 pb-2"><%= @category.name %></h2>
  <p class="text-center text-gray-600 mb-6">ポモドーロ・テクニックを使って集中しよう☕<br>開始ボタンでタイマースタート</p>
  <%= form_with model: @log, url: logs_path, method: :post, local: true, class: "w-full max-w-md mb-8 mx-auto", id: "timer-form" do |f| %>
    <div class="mb-6">
      <%= hidden_field_tag "log[category_id]", @category.id %>
      <%= hidden_field_tag "log[start_time]", "", id: "log-start-time" %>
      <%= hidden_field_tag "log[end_time]", "", id: "log-end-time" %>
      <%= hidden_field_tag "log[duration]", "", id: "log-duration" %>
    </div>
  <% end %>
  <div class="flex w-1/2 mx-auto mb-6 border-b border-gray-200 select-none">
    <div id="work-tab" class="active w-1/2 text-center py-2 font-semibold text-blue-900 border-b-2 border-blue-900 cursor-pointer">
      学習
    </div>
    <div id="break-tab" class="w-1/2 text-center py-2 font-semibold text-gray-500 hover:text-blue-800 cursor-pointer">
      休憩
    </div>
  </div>
  <div id="timer" class="flex flex-col items-center gap-8">
    <%# タイマー秒数表示 %>
    <div class="font-bold tabular-nums tracking-wider text-9xl my-10">
      <span id="timer-display">25:00</span>
    </div>
    <%# タイマー操作ボタン %>
    <div class="flex items-center gap-4 mb-5">
      <button id="btn-start"
              class="bg-blue-900 text-white font-semibold py-3 px-8 rounded hover:bg-blue-800 hover:cursor-pointer transition">
        開始
      </button>
      <button id="btn-pause"
              class="hidden bg-gray-200 text-gray-700 font-semibold py-3 px-8 rounded hover:bg-gray-300 hover:cursor-pointer transition">
        一時停止
      </button>
      <button id="btn-finish"
              class="hidden bg-emerald-600 text-white font-semibold py-3 px-8 rounded hover:bg-emerald-700 hover:cursor-pointer transition">
        終了
      </button>
    </div>
  </div>
</section>

<%# 学習記録一覧（選択したカテゴリのみ） %>
<section class="max-w-3xl mx-auto px-4 my-10">
  <h2 class="text-2xl font-bold text-blue-900 my-6 border-b border-blue-900 pb-2"><%= @category.name %>の学習記録</h2>
  <button>
    <%= link_to "手動で追加する" , new_log_path(category_id: @category.id),
      class: "inline-block mb-4 bg-blue-900 text-white font-semibold py-2 px-4 rounded hover:bg-blue-800 hover:cursor-pointer transition" %>
  </button>
  <% if @logs.present? %>
    <ul class="divide-y divide-gray-200 rounded-xl border border-gray-200 bg-white">
      <% @logs.each do |log| %>
        <%= render "logs/log", log: log %>
      <% end %>
    </ul>
  <% else %>
    <div class="rounded-xl border border-dashed p-8 text-center text-gray-600 bg-white">
      <p>このカテゴリの学習記録はまだありません。<br>タイマーで「開始」して記録しましょう。</p>
    </div>
  <% end %>
</section>

<script>
  // Worker定義
  const workerSrc = `
    let leftSec;
    let paused;
    let timerId;

    const postTick = () => {
      self.postMessage({ type: 'tick', leftSec });
    };

    const clearTimer = () => {
      if (timerId !== null) {
        clearInterval(timerId);
        timerId = null;
      }
    };

    // Main → Workerのイベントリスナー
    self.addEventListener('message', (e) => {
      const msg = e.data || {};
      switch (msg.type) {
        case 'start': {
          clearTimer();
          leftSec = (msg.leftSec);
          paused = false;
          postTick();

          timerId = setInterval(() => {
            // 一時停止中はスキップ
            if (paused) return;
            if (leftSec > 0) {
              leftSec -= 1;
              postTick();
              if (leftSec === 0) {
                clearTimer();
                self.postMessage({ type: 'done' });
              }
            }
          }, 1000);
          break;
        }

        case 'pause': {
          paused = true;
          break;
        }

        case 'resume': {
          paused = false;
          break;
        }

        case 'stop': {
          clearTimer();
          self.postMessage({ type: 'stopped' });
          break;
        }
      }
    });
  `;

  // Worker生成
  const blob = new Blob([workerSrc], { type: "application/javascript" });
  const workerURL = URL.createObjectURL(blob);
  const worker = new Worker(workerURL);

  document.addEventListener("turbo:load", () => {
    const workTab = document.getElementById("work-tab");
    const breakTab = document.getElementById("break-tab");
    const timerDisplay = document.getElementById("timer-display");
    const startBtn = document.getElementById("btn-start");
    const pauseBtn = document.getElementById("btn-pause");
    const finishBtn = document.getElementById("btn-finish");
    const form = document.getElementById("timer-form");
    const startField = document.getElementById("log-start-time");
    const endField = document.getElementById("log-end-time");
    const durationField = document.getElementById("log-duration");

    const activeClassArr   = ["active", "text-blue-900", "border-b-2", "border-blue-900"];
    const inactiveClassArr = ["text-gray-500", "hover:text-blue-800"];

    // モード定義
    const Mode = { WORK: "work", BREAK: "break" };
    const DURATION_BY_MODE = { [Mode.WORK]: 25 * 60, [Mode.BREAK]: 5 * 60 };  // LSB: 1秒

    let intervalId = null;
    let leftSec; // LSB: 1sec
    let isPaused = false;
    let startedLeftSec;
    let startedAt;

    // Worker → Mainのイベントリスナー
    worker.onmessage = (e) => {
      const msg = e.data;

      switch (msg.type) {
        case 'tick': {
          leftSec = msg.leftSec;
          updateTimerDisplay();
          break;
        };

        case "done": {
          intervalId = null;
          alert("終了！");
          submitLog(Date.now());
          isPaused = false;
          leftSec = DURATION_BY_MODE[currentMode()];
          showIdleUI();
          startedLeftSec = null;
          startedAt = null;
          updateTimerDisplay();
          break;
        };

        case "stopped": {
          intervalId = null;
          submitLog(Date.now());
          isPaused = false;
          leftSec = DURATION_BY_MODE[currentMode()];
          showIdleUI();
          startedLeftSec = null;
          startedAt = null;
          updateTimerDisplay();
          break;
        }
      }
    };

    worker.addEventListener("error", (err) => {
      console.error(err);
    });

    // タイマーページ以外では何もしない
    if (!workTab) {
      return;
    };

    // タイマー動作中かチェック関数
    const isRunning = () => {
      return intervalId !== null;
    };

    // 現在のモード取得
    const currentMode = () => {
      return workTab.classList.contains("active") ? Mode.WORK : Mode.BREAK;
    };

    // 学習／休憩タブの切り替え
    const setActiveTab = (activeEl, inactiveEl) => {
      activeEl.classList.remove(...inactiveClassArr);
      activeEl.classList.add(...activeClassArr);

      inactiveEl.classList.remove(...activeClassArr);
      inactiveEl.classList.add(...inactiveClassArr);
    };

    // 1桁目を0埋めする関数
    const zeroPadding = (n) => {
      return String(n).padStart(2, "0")
    };

    // MM:SS の形式にフォーマットする関数
    const formatMMSS = (sec) => {
      return `${zeroPadding(Math.floor(sec / 60))}:${zeroPadding(sec % 60)}`
    };

    // Rails用フォーマット YYYY-MM-DD HH:MM:SS
    const toRailsTS = (ms) => {
      const d = new Date(ms);
      const Y = d.getFullYear(), M = zeroPadding(d.getMonth()+1), D = zeroPadding(d.getDate());
      const h = zeroPadding(d.getHours()), m = zeroPadding(d.getMinutes()), s = zeroPadding(d.getSeconds());
      return `${Y}-${M}-${D} ${h}:${m}:${s}`;
    };

    // ログ送信処理
    const submitLog = (endedAt) => {
      // 休憩時間は保存しない
      if (currentMode() !== Mode.WORK) {
        return;
      };

      const duration = Math.floor((startedLeftSec - leftSec) / 60);
      // 1分未満なら保存しない
      if (duration === 0) {
        return;
      }

      startField.value  = toRailsTS(startedAt);
      endField.value = toRailsTS(endedAt);
      durationField.value = duration;
      form.submit();
    };

    // タイマー・ブラウザタブの残り秒数更新
    const updateTimerDisplay = () => {
      timerDisplay.textContent = formatMMSS(leftSec);
      document.title = `${formatMMSS(leftSec)}`;
    };

    // タブを有効化する共通関数
    const activateMode = (newMode) => {
      // タイマー動作中はタブ切り替え不可
      if (isRunning()) {
        return;
      }
      const isWork = (newMode === Mode.WORK);
      leftSec = DURATION_BY_MODE[newMode];
      setActiveTab((isWork ? workTab : breakTab), (isWork ? breakTab : workTab)); // 三項演算子で引数を切り替えてる
      updateTimerDisplay();
    };

    // 学習タブクリック
    workTab.addEventListener("click", () => {
      if (!workTab.classList.contains("active")) {
        activateMode(Mode.WORK);
      };
    });

    // 休憩タブクリック
    breakTab.addEventListener("click", () => {
      if (!breakTab.classList.contains("active")) {
        activateMode(Mode.BREAK);
      }
    });

    // UI切替（初期状態→タイマー作動）
    const showRunningUI = () => {
      startBtn.classList.add("hidden");
      pauseBtn.classList.remove("hidden");
      finishBtn.classList.remove("hidden");
    };

    // UI切り替え（タイマー作動状態→初期状態）
    const showIdleUI = () => {
      startBtn.classList.remove("hidden");
      pauseBtn.classList.add("hidden");
      finishBtn.classList.add("hidden");
      pauseBtn.innerText = "一時停止";
      timerDisplay.classList.remove("text-gray-600");
    };

    // 開始ボタンクリック
    startBtn.addEventListener("click", () => {
      if (isRunning()) return; // 二重起動ガード

      startedLeftSec = leftSec;
      startedAt = Date.now();

      worker.postMessage({ type: "start", leftSec: leftSec });

      // 従来コード互換：動作中判定用にダミー値をセット
      intervalId = 1;

      showRunningUI();
      updateTimerDisplay();
    });

    // 一時停止ボタンクリック
    pauseBtn.addEventListener("click", () => {
      if (!isRunning()) return; // 開始前は無視

      isPaused = !isPaused;
      pauseBtn.innerText = isPaused ? "再開" : "一時停止";
      timerDisplay.classList.toggle("text-gray-600", isPaused);
      worker.postMessage({ type: isPaused ? "pause" : "resume" });
    });

    // 終了ボタンクリック
    finishBtn.addEventListener("click", () => {
      if (!isRunning()) return; // 開始前は無視

      worker.postMessage({ type: "stop" });
    });

    // 初期表示
    activateMode(Mode.WORK);

    document.addEventListener("turbo:before-visit", (e) => {
      if (isRunning()) {
        e.preventDefault();
        alert("タイマーが動作中はページを移動できません。");
      }
    });
  });

  (function () {
  const CSRF = "<%= form_authenticity_token %>";

  function ensureMenu() {
    let m = document.getElementById("floating-kebab-menu");
    if (!m) {
      m = document.createElement("div");
      m.id = "floating-kebab-menu";
      m.className = "hidden border border-gray-200 bg-white rounded-lg shadow w-40 p-1";
      m.style.position = "fixed"; // レイアウトに影響しない
      document.body.appendChild(m);
    }
    return m;
  }

  function buildMenuHTML(editUrl, deleteUrl, name) {
    return `
      <a href="${editUrl}" class="block px-3 py-2 text-sm hover:bg-gray-50" role="menuitem">編集</a>
      <form method="post" action="${deleteUrl}" class="block" role="menuitem"
            onsubmit="return confirm('${name} を削除します。よろしいですか？')">
        <input type="hidden" name="authenticity_token" value="${CSRF}">
        <input type="hidden" name="_method" value="delete">
        <button type="submit" class="w-full text-left px-3 py-2 text-sm hover:bg-gray-50">削除</button>
      </form>
    `;
  }

  let openBtn = null;

  document.addEventListener("click", (e) => {
    const btn = e.target.closest("[data-kebab-button]");
    const menu = ensureMenu();

    // 外側クリック → 閉じる
    if (!btn) {
      if (!menu.classList.contains("hidden")) menu.classList.add("hidden");
      openBtn = null;
      return;
    }

    // 同じボタン → トグル閉じ
    if (openBtn === btn && !menu.classList.contains("hidden")) {
      menu.classList.add("hidden"); openBtn = null; return;
    }

    // 内容差し替え
    menu.innerHTML = buildMenuHTML(
      btn.getAttribute("data-edit-url"),
      btn.getAttribute("data-delete-url"),
      btn.getAttribute("data-name") || "このログ"
    );

    // 位置：ボタン直下・右寄せ（画面外は補正）
    const r = btn.getBoundingClientRect();
    const top = r.bottom + 6;
    menu.style.top = top + "px";
    menu.classList.remove("hidden");
    const mw = menu.offsetWidth || 160;
    const left = Math.min(Math.max(8, r.right - mw), window.innerWidth - mw - 8);
    menu.style.left = left + "px";

    openBtn = btn;
  });

  ["keydown", "scroll", "resize"].forEach((ev) => {
    window.addEventListener(ev, (e) => {
      if (ev === "keydown" && e.key !== "Escape") return;
      const m = document.getElementById("floating-kebab-menu");
      if (m) m.classList.add("hidden");
      openBtn = null;
    }, { passive: true });
  });
})();
</script>
